### 오늘 한 일
- 모던 자바스크립트 Deep Dive
25. 클래스
26. ES6 함수의 추가 기능
___
### 배운 것
>
- 상속 클래스의 인스턴스 생성 과정
1. 서브클래스의 super 호출 (서브클래스는 자신이 직접 인스턴스를 생성하지 않고 슈퍼클래스에게 인스턴스 생성을 위임한다. 따라서 서브클래스의 constructor에서 반드시 super를 호출해야 한다)
2. 슈퍼클래스의 인스턴스(빈 객체) 생성 후 this 바인딩
3. 슈퍼클래스의 인스턴스 초기화
4. 서브클래스의 constructor로 제어흐름 복귀 후 super가 반환한 인스턴스를 this에 바인딩
5. 서브클래스 인스턴스 초기화
6. 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환
- extends 키워드 다음에는 클래스뿐만 아니라 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다
- String, Number, Array 같은 표준 빌트인 객체도 [[Construct]] 내부 메서드를 갖는 생성자 함수이므로 extends를 사용하여 확장할 수 있다

>
- ES6 이전의 함수는 동일한 함수라도 다양한 형태로 호출할 수 있다. (일반적인 함수로서, 생성자 함수로서, 메서드로서 호출)
- ES6에서는 함수를 사용 목적에 따라 일반 함수, 메서드, 화살표 함수의 세 가지 종류로 구분한다
- ES6에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다
- ES6 메서드는 인스턴스를 생성할 수 없는 non-constructor다
- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다
- 화살표 함수와 일반 함수의 차이
1. 화살표 함수는 non-constructor다
2. 중복된 매개변수 이름 사용 불가
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다
- 화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다 : lexical this
- 화살표 함수는 위와 같은 특징 덕분에 다른 함수의 인수로 전달되어 콜백 함수로 유용하게 사용된다
